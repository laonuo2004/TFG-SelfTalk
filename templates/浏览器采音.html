<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>æµè§ˆå™¨é‡‡éŸ³ Â· å®æ—¶å¯¹è¯ Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,'Noto Sans',sans-serif;
         background:#0b1118;color:#e9f4ff;margin:0;padding:32px}
    .card{max-width:880px;margin:0 auto;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.12);
          border-radius:14px;padding:20px;box-shadow:0 8px 40px rgba(0,0,0,.35)}
    h1{margin:0 0 6px;font-size:22px;letter-spacing:.06em}
    .muted{opacity:.75;font-size:13px;margin-bottom:14px}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    button{padding:10px 14px;border-radius:999px;border:1px solid rgba(0,229,255,.5);background:rgba(0,0,0,.35);
           color:#cfefff;cursor:pointer}
    button.primary{background:linear-gradient(120deg,#00c6ff,#0072ff);border:none;color:#fff}
    input[type=text]{flex:1;min-width:240px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,.18);
                     background:rgba(0,0,0,.35);color:#eaf6ff}
    #log{margin-top:12px;height:200px;overflow:auto;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.1);
         border-radius:10px;padding:10px;font-family:ui-monospace,Menlo,Monaco,Consolas,monospace;font-size:12px}
    .badge{display:inline-flex;align-items:center;gap:8px;padding:4px 10px;border-radius:999px;background:rgba(0,0,0,.45);
           border:1px solid rgba(0,229,255,.5);font-size:12px;color:#cfefff;margin-right:8px}
    .dot{width:7px;height:7px;border-radius:50%;background:linear-gradient(#00ffbf,#00e5ff);box-shadow:0 0 8px #00e5ff}
    .meter{width:160px;height:12px;background:#101820;border-radius:999px;border:1px solid rgba(255,255,255,.14);
           overflow:hidden;position:relative}
    .meter > i{display:block;height:100%;width:0;background:linear-gradient(90deg,#1dd1a1,#00e5ff);}
  </style>
</head>
<body>
  <div class="card">
    <div class="badge"><i class="dot"></i> BROWSER MIC â†’ WS â†’ VOLC ENGINE</div>
    <h1>æµè§ˆå™¨é‡‡éŸ³ Â· å®æ—¶å¯¹è¯</h1>
    <div class="muted">ä¸€é”®å¼€å§‹/åœæ­¢å½•éŸ³ï¼›æ–‡æœ¬æ¶ˆæ¯ä¹Ÿå¯ç›´æ¥å‘é€ã€‚éŸ³é¢‘ä¸ TTS ç»Ÿä¸€ä½¿ç”¨ PCM S16LE / 16kHz / monoã€‚</div>

    <div class="row" style="margin-bottom:10px">
      <button id="btnToggle" class="primary">ğŸ™ï¸ å¼€å§‹å½•éŸ³</button>
      <div class="meter"><i id="vu"></i></div>
      <span id="srLabel" class="muted">é‡‡æ ·ç‡ï¼šâ€”</span>
    </div>

    <div class="row">
      <input id="textInput" type="text" placeholder="è¾“å…¥æ–‡æœ¬å¹¶å‘é€ç»™æ¨¡å‹â€¦" />
      <button id="btnSend">å‘é€æ–‡æœ¬</button>
      <button id="btnConnect">é‡æ–°è¿æ¥</button>
    </div>

    <div id="log"></div>
  </div>

<script>
/** é…ç½®ï¼šæŠŠå®ƒæ”¹æˆä½ çš„æœåŠ¡å™¨åœ°å€ï¼ˆç”Ÿäº§å»ºè®®èµ° wss:// å¹¶åŒæºéƒ¨ç½²ï¼‰ */
const WS_URL = "wss://u811623-a935-f5308807.bjb1.seetacloud.com:8443";

/** å…¨å±€çŠ¶æ€ */
let ws;
let started = false;
let audioCtx, micNode, gainNode, workletNode;
let nextPlayTime = 0; // æ’­æ”¾æ’é˜Ÿ
let meterLast = 0;

/** UI ä¾¿æ·å‡½æ•° */
const logView = document.getElementById('log');
function logLine(...args){
  const s = args.map(x => (typeof x === 'string' ? x : JSON.stringify(x))).join(' ');
  logView.textContent += s + "\n";
  logView.scrollTop = logView.scrollHeight;
}
function setBtnRecording(on){
  const btn = document.getElementById('btnToggle');
  btn.textContent = on ? "â¹ï¸ åœæ­¢å½•éŸ³" : "ğŸ™ï¸ å¼€å§‹å½•éŸ³";
  btn.classList.toggle('primary', !on);
}

/** å»ºç«‹ WebSocket è¿æ¥ */
async function ensureWS(){
  if (ws && ws.readyState === WebSocket.OPEN) return ws;
  if (ws) try{ ws.close(); }catch{}
  ws = new WebSocket(WS_URL);
  ws.binaryType = "arraybuffer";

  ws.addEventListener('open', ()=>{ logLine("[WS] open"); });
  ws.addEventListener('close', ()=>{ logLine("[WS] close"); });
  ws.addEventListener('error', (e)=>{ logLine("[WS] error", String(e)); });

  ws.addEventListener('message', async (ev) => {
    if (typeof ev.data === 'string') {
      try { logLine("[WS text]", JSON.parse(ev.data)); } catch { logLine("[WS text]", ev.data); }
    } else {
      // äºŒè¿›åˆ¶ï¼šTTS PCM S16LE/16k/mono
      const ab = ev.data instanceof ArrayBuffer ? ev.data : await ev.data.arrayBuffer?.();
      if (!ab) return;
      enqueuePCM(new Int16Array(ab), 16000);
    }
  });

  await new Promise(res => ws.addEventListener('open', res, {once:true}));
  return ws;
}

/** æ’­æ”¾ï¼šæŠŠ Int16 PCM æ’é˜Ÿé€å…¥ AudioContext æ’­æ”¾ï¼Œé¿å…çˆ†éŸ³ä¸å¡é¡¿ */
function enqueuePCM(int16, sampleRate = 16000){
  if (!audioCtx) initAudioContext(false); // åªä¸ºæ’­æ”¾åœºæ™¯åˆå§‹åŒ–
  const buf = audioCtx.createBuffer(1, int16.length, sampleRate);
  const ch0 = buf.getChannelData(0);
  for (let i = 0; i < int16.length; i++) ch0[i] = int16[i] / 32768;
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  src.connect(audioCtx.destination);
  const startAt = Math.max(audioCtx.currentTime, nextPlayTime);
  src.start(startAt);
  nextPlayTime = startAt + buf.duration;
}

/** åˆå§‹åŒ–éŸ³é¢‘å›¾å¹¶åŠ è½½ Workletï¼ˆå«ç®€å•é‡é‡‡æ ·åˆ° 16kHzï¼‰ */
async function initAudioContext(forCapture = true){
  if (audioCtx) return audioCtx;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
  const sr = audioCtx.sampleRate;
  document.getElementById('srLabel').textContent = `é‡‡æ ·ç‡ï¼š${sr} Hz`;

  // åŠ¨æ€åˆ›å»º Worklet JSï¼ˆå°†è¾“å…¥ sampleRate é‡é‡‡æ ·åˆ° 16kï¼Œè¾“å‡º Int16 20ms å¸§ï¼‰
  const workletCode = `
  class PCM16KEnc extends AudioWorkletProcessor {
    constructor(){
      super();
      // è¾“å…¥é‡‡æ ·ç‡ï¼ˆç”±æµè§ˆå™¨å®é™…æä¾›ï¼‰
      this.inRate = sampleRate;
      this.outRate = 16000;
      this.step = this.inRate / this.outRate;
      this.pos = 0;                   // åœ¨è¾“å…¥ç¼“å†²ä¸­çš„å°æ•°ä½ç½®
      this.src = new Float32Array(0); // ç´¯è®¡è¾“å…¥
      this.buf = []; this.len = 0;    // è¾“å‡º Int16 æš‚å­˜
      this.frame = 320;               // 20ms@16k
    }
    _appendInput(chunk){
      // æ‹¼æ¥è¾“å…¥å—
      const merged = new Float32Array(this.src.length + chunk.length);
      merged.set(this.src, 0); merged.set(chunk, this.src.length);
      this.src = merged;
    }
    _resample(){
      // æŠŠ src æŒ‰ step é‡é‡‡æ ·åˆ° 16kï¼Œçº¿æ€§æ’å€¼
      if (this.src.length < 2) return new Float32Array(0);
      let out = [];
      while (this.pos + 1 < this.src.length){
        const i = Math.floor(this.pos);
        const frac = this.pos - i;
        const a = this.src[i], b = this.src[i+1];
        const y = a + (b - a) * frac;
        out.push(y);
        this.pos += this.step;
      }
      // ä¸¢å¼ƒå·²ç”¨çš„æ•´æ®µè¾“å…¥ï¼Œä¿ç•™ä½™é‡ä»¥ä¾¿ä¸‹æ¬¡æ’å€¼
      const drop = Math.floor(this.pos);
      this.src = this.src.subarray(drop);
      this.pos -= drop;
      return new Float32Array(out);
    }
    _f32_to_i16(f){
      const i16 = new Int16Array(f.length);
      for (let i=0;i<f.length;i++){
        let s = Math.max(-1, Math.min(1, f[i]));
        i16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return i16;
    }
    _post_frames(i16){
      this.buf.push(i16); this.len += i16.length;
      while (this.len >= this.frame){
        let need = this.frame, out = new Int16Array(need), off = 0;
        while (need > 0){
          let cur = this.buf[0];
          if (cur.length <= need){ out.set(cur, off); off += cur.length; need -= cur.length; this.buf.shift(); }
          else { out.set(cur.subarray(0, need), off); this.buf[0] = cur.subarray(need); off += need; need = 0; }
        }
        this.len -= this.frame;
        this.port.postMessage(out.buffer, [out.buffer]); // ç›´æ¥æŠŠ ArrayBuffer ä»¥äºŒè¿›åˆ¶å‘åˆ°ä¸»çº¿ç¨‹
      }
    }
    process(inputs){
      const ch = inputs[0] && inputs[0][0];
      if (ch && ch.length){
        this._appendInput(ch);
        const f16k = this._resample();
        if (f16k.length){
          const i16 = this._f32_to_i16(f16k);
          this._post_frames(i16);
        }
      }
      return true;
    }
  }
  registerProcessor('pcm16k-enc', PCM16KEnc);
  `;
  const blobURL = URL.createObjectURL(new Blob([workletCode], {type:'application/javascript'}));
  await audioCtx.audioWorklet.addModule(blobURL);

  if (!forCapture) return audioCtx;

  // è·å–éº¦å…‹é£
  const stream = await navigator.mediaDevices.getUserMedia({
    audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true, autoGainControl: true },
    video: false
  });

  micNode = audioCtx.createMediaStreamSource(stream);
  gainNode = audioCtx.createGain();  // æŠŠè‡ªå·±å£°éŸ³é™éŸ³ï¼ˆä¸å›æ”¾ï¼‰
  gainNode.gain.value = 0.0;

  workletNode = new AudioWorkletNode(audioCtx, 'pcm16k-enc');
  workletNode.port.onmessage = (ev) => {
    // è¿™é‡Œæ‹¿åˆ°çš„æ˜¯ 20ms ä¸€å¸§çš„ Int16 PCM çš„ ArrayBuffer
    if (ws && ws.readyState === WebSocket.OPEN && started){
      ws.send(ev.data);
    }
  };

  // ç®€æ˜“ç”µå¹³è¡¨ï¼ˆç”¨åŸå§‹è¾“å…¥ï¼‰
  const analyser = audioCtx.createAnalyser();
  analyser.fftSize = 512;
  const data = new Uint8Array(analyser.frequencyBinCount);
  function raf(){
    if (analyser) {
      analyser.getByteTimeDomainData(data);
      // å³°å€¼æ£€æµ‹
      let peak = 0;
      for (let i=0;i<data.length;i++){
        const v = (data[i]-128)/128;
        peak = Math.max(peak, Math.abs(v));
      }
      const smooth = meterLast * 0.85 + peak * 0.15;
      meterLast = smooth;
      document.getElementById('vu').style.width = Math.min(100, Math.round(smooth*100)) + "%";
    }
    requestAnimationFrame(raf);
  }
  requestAnimationFrame(raf);

  // è¿æ¥éŸ³é¢‘å›¾ï¼šmic -> analyser -> worklet -> (é™éŸ³) -> destination
  micNode.connect(analyser);
  micNode.connect(workletNode);
  workletNode.connect(gainNode).connect(audioCtx.destination);

  return audioCtx;
}

/** å¼€å§‹å½•éŸ³ï¼šå»ºç«‹ WSã€åˆå§‹åŒ–éŸ³é¢‘ã€é€šçŸ¥åç«¯ start */
async function startRecording(){
  await ensureWS();
  await initAudioContext(true);
  ws.send(JSON.stringify({type:"control", op:"start"}));
  started = true; setBtnRecording(true);
  logLine("[REC] start");
}

/** åœæ­¢å½•éŸ³ï¼šåœæ­¢æ¨æµå¹¶é€šçŸ¥åç«¯ stop */
async function stopRecording(){
  started = false; setBtnRecording(false);
  if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({type:"control", op:"stop"}));
  // é‡Šæ”¾éŸ³é¢‘èµ„æºï¼ˆå¯é€‰ï¼šä¹Ÿå¯ä»¥ä¿æŒ AudioContext æŒç»­å­˜åœ¨ä»¥ä¾¿å¿«é€Ÿå†å¼€ï¼‰
  try{ workletNode && workletNode.disconnect(); }catch{}
  try{ gainNode && gainNode.disconnect(); }catch{}
  try{ micNode && micNode.disconnect(); }catch{}
  workletNode = gainNode = micNode = null;
  logLine("[REC] stop");
}

/** ç»‘å®š UI */
document.getElementById('btnToggle').onclick = async ()=>{
  if (!started) { await startRecording(); } else { await stopRecording(); }
};
document.getElementById('btnConnect').onclick = async ()=>{
  await ensureWS(); logLine("[WS] reconnected");
};
document.getElementById('btnSend').onclick = async ()=>{
  const v = document.getElementById('textInput').value.trim();
  if (!v) return;
  await ensureWS();
  ws.send(JSON.stringify({type:"control", op:"text", text: v}));
  logLine(">>", v);
  document.getElementById('textInput').value = "";
};
</script>
</body>
</html>
