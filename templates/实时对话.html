<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>实时对话界面 - DATA HAMMER GROUP</title>
  <style>
    body { font-family: 'Microsoft YaHei', sans-serif; margin: 0; }
    body.main-bg {
      background: radial-gradient(circle at top, #05070a 0%, #050608 35%, #000000 100%);
      color: #fff; min-height: 100vh; display: flex; flex-direction: column;
    }
    .nav { display:flex; align-items:center; justify-content:space-between; padding:14px 32px;
      border-bottom:1px solid rgba(255,255,255,0.08); backdrop-filter: blur(12px);
      background: linear-gradient(90deg, rgba(0,229,255,0.18), rgba(0,0,0,0.6), rgba(0,229,255,0.08));
      position: sticky; top: 0; z-index: 20;
    }
    .nav-logo { display:flex; align-items:center; gap:10px; }
    .nav-logo-mark { width:26px; height:26px; border-radius:10px;
      background: conic-gradient(from 200deg, #00e5ff, #0072ff, #00ffbf, #00e5ff);
      box-shadow: 0 0 18px rgba(0,229,255,0.8); position:relative;
    }
    .nav-logo-mark::after { content:""; position:absolute; inset:4px; border-radius:8px;
      background: radial-gradient(circle at 30% 20%, #0b1b26, #020509);
    }
    .nav-logo-text-main { font-size:1.05rem; letter-spacing:0.12em; }
    .nav-logo-text-sub { font-size:0.75rem; opacity:0.6; }
    .nav-links { display:flex; gap:22px; font-size:0.95rem; }
    .nav-links a { color:rgba(255,255,255,0.75); text-decoration:none; position:relative; padding-bottom:4px; cursor:pointer; }
    .nav-links a::after { content:""; position:absolute; left:0; bottom:0; width:0; height:2px; border-radius:999px;
      background:linear-gradient(90deg, #00e5ff, #00ffbf); transition: width .25s ease;
    }
    .nav-links a:hover::after { width:100%; }
    .nav-cta { padding:8px 18px; border-radius:999px; border:1px solid rgba(0,229,255,0.5);
      background: radial-gradient(circle at 0 0, rgba(0,229,255,0.35), transparent);
      font-size:0.9rem; cursor:pointer; color:#e6faff; transition:all .25s ease;
    }
    .nav-cta:hover { transform: translateY(-1px); box-shadow:0 0 18px rgba(0,229,255,0.45);
      background: radial-gradient(circle at 100% 0, rgba(0,229,255,0.5), transparent);
    }
    @media (max-width:960px){ .nav{ padding:10px 16px; } }

    .page-wrapper{ flex:1; display:flex; justify-content:center; padding:24px 16px 24px; }
    .page-inner{ width:100%; max-width:980px; display:flex; flex-direction:column; gap:18px; margin:0 auto; }

    .hero-card{
      background: radial-gradient(circle at top left, rgba(0,229,255,0.18), transparent 55%), rgba(255,255,255,0.02);
      border-radius:18px; padding:22px 20px 20px; border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 0 30px rgba(0,229,255,0.18), 0 0 90px rgba(0,0,0,0.85);
      backdrop-filter: blur(12px); position:relative; overflow:hidden; margin:0 auto; width:100%; text-align:center;
    }
    .hero-card::before{
      content:"DATA • HAMMER • REALTIME • TALKING"; position:absolute; top:10px; right:-40px;
      font-size:0.65rem; letter-spacing:0.35em; color:rgba(255,255,255,0.08); transform: rotate(-6deg); white-space:nowrap;
    }
    .badge{ display:inline-flex; align-items:center; gap:8px; padding:4px 10px; border-radius:999px;
      background:rgba(0,0,0,0.45); border:1px solid rgba(0,229,255,0.5); font-size:0.75rem; color:#cfefff; margin-bottom:14px;
    }
    .badge-dot{ width:7px; height:7px; border-radius:999px; background: radial-gradient(circle, #00ffbf, #00e5ff);
      box-shadow:0 0 10px rgba(0,229,255,0.9);
    }
    .headline{ font-size:1.8rem; margin:0 0 10px; letter-spacing:0.08em; }
    .headline span{ color:#00e5ff; }
    .subline{ font-size:0.92rem; color:rgba(226,244,255,0.85); max-width:720px; line-height:1.7; margin:0 auto 4px; text-align:center; }
    .status-pill{ display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px;
      font-size:0.78rem; color:#cfefff; background:rgba(0,0,0,0.55); border:1px solid rgba(0,229,255,0.45); margin-top:6px;
    }
    .status-dot{ width:7px; height:7px; border-radius:999px; background:#ff4b6a; box-shadow:0 0 8px rgba(255,75,106,0.8); }
    .status-dot.online{ background:#00ffbf; box-shadow:0 0 8px rgba(0,255,191,0.8); }

    .video-page-container{
      display:flex; gap:18px;
      background: radial-gradient(circle at top left, rgba(0,229,255,0.18), transparent 55%), rgba(255,255,255,0.03);
      border-radius:18px; padding:18px; border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 0 30px rgba(0,229,255,0.18), 0 0 90px rgba(0,0,0,0.85);
      backdrop-filter: blur(14px); width:100%; max-width:980px; margin:0 auto;
    }
    @media (max-width:900px){ .video-page-container{ flex-direction:column; } }

    .dialog-display{ flex:1.1; padding:10px; display:flex; flex-direction:column; gap:10px; }
    .dialog-card{
      background:rgba(5,10,20,0.9); border-radius:14px; border:1px solid rgba(255,255,255,0.14);
      padding:12px 12px 10px; box-shadow:0 0 20px rgba(0,229,255,0.15); height:260px; display:flex; flex-direction:column;
    }
    .dialog-card-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;
      font-size:0.86rem; color:rgba(220,236,255,0.9); }
    .chat-log{ flex:1; overflow-y:auto; padding-right:4px; font-size:0.86rem; }
    .chat-msg{ margin-bottom:6px; line-height:1.5; }
    .chat-msg span.role{ display:inline-block; min-width:46px; font-size:0.78rem; padding:1px 8px; border-radius:999px; margin-right:4px; }
    .chat-msg.user span.role{ background:rgba(0,229,255,0.2); color:#9be9ff; }
    .chat-msg.assistant span.role{ background:rgba(0,255,191,0.18); color:#b6ffe5; }
    .chat-msg.system span.role{ background:rgba(255,255,255,0.08); color:#e0edff; }
    .chat-msg .content{ color:rgba(235,245,255,0.92); }
    .small-hint{ font-size:0.78rem; color:rgba(200,220,240,0.7); margin-top:4px; }

    .form-section{ flex:0.9; padding:16px 18px; background:rgba(5,10,20,0.92);
      border-radius:14px; border:1px solid rgba(255,255,255,0.12); box-shadow:0 0 20px rgba(0,229,255,0.15);
    }
    .form-group{ margin-bottom:12px; }
    label{ display:block; margin-bottom:6px; font-weight:500; color:rgba(230,243,255,0.9); font-size:0.9rem; }
    input, textarea{
      width:100%; padding:9px 10px; border:1px solid rgba(255,255,255,0.15); border-radius:8px;
      font-size:0.9rem; box-sizing:border-box; background:rgba(0,0,0,0.35); color:#eaf6ff; outline:none; resize:vertical;
    }
    input:focus, textarea:focus{ border-color:#00e5ff; box-shadow:0 0 0 1px rgba(0,229,255,0.4); }
    textarea{ min-height:70px; max-height:140px; }
    .btn-row{ display:flex; gap:10px; margin-top:2px; }
    .primary-btn, .secondary-btn{ flex:1; padding:9px; border-radius:999px; border:none; font-size:0.9rem; cursor:pointer; transition:all .25s ease; }
    .primary-btn{ background:linear-gradient(120deg, #00c6ff, #0072ff); color:#fff; box-shadow:0 0 16px rgba(0,229,255,0.4); }
    .primary-btn:hover{ background:linear-gradient(120deg, #0072ff, #00e5ff); transform:translateY(-1px); box-shadow:0 0 22px rgba(0,229,255,0.7); }
    .secondary-btn{ background:rgba(0,0,0,0.4); color:rgba(230,243,255,0.9); border:1px solid rgba(255,255,255,0.2); }
    .secondary-btn:hover{ background:rgba(15,25,40,0.9); }
    .footer{ text-align:center; padding:8px 0 14px; font-size:0.8rem; color:rgba(255,255,255,0.35); }
    .inline-text{ font-size:0.8rem; color:rgba(200,220,240,0.8); }
  </style>
</head>

<body class="main-bg">
  <header class="nav">
    <div class="nav-logo">
      <div class="nav-logo-mark"></div>
      <div>
        <div class="nav-logo-text-main">DATA HAMMER GROUP</div>
        <div class="nav-logo-text-sub">Intelligent Talking System</div>
      </div>
    </div>
    <nav class="nav-links">
      <a href="/">首页</a>
      <a href="/chat_system">人机对话</a>
      <a href="/model_training">模型训练</a>
      <a href="/video_generation">视频生成</a>
      <a href="/实时对话.html">实时对话</a>
      <a href="/about">关于我们</a>
    </nav>
    <button class="nav-cta" onclick="window.location.href='/'">返回首页</button>
  </header>

  <main class="page-wrapper">
    <div class="page-inner">
      <div class="hero-card">
        <div class="badge"><div class="badge-dot"></div><span>REALTIME · DATA HAMMER TALKING SYSTEM</span></div>
        <h1 class="headline">实时对话界面 · <span>LIVE</span></h1>
        <p class="subline">使用本地麦克风与云端对话模型实时交流 · 语音输入 · 语音输出 · 低延迟</p>
        <div class="status-pill">
          <div id="statusDot" class="status-dot"></div>
          <span id="statusText">未连接</span>
        </div>
      </div>

      <div class="video-page-container">
        <div class="dialog-display">
          <div class="dialog-card">
            <div class="dialog-card-header">
              <span>对话记录 · Transcript</span>
              <span class="inline-text" id="latencyLabel">等待连接...</span>
            </div>
            <div id="chatLog" class="chat-log">
              <div class="chat-msg system">
                <span class="role">系统</span>
                <span class="content">点击右侧「连接 + 开始语音」按钮，允许浏览器使用麦克风，即可开始实时对话。</span>
              </div>
            </div>
            <div class="small-hint">提示：为了更好的麦克风权限体验，建议使用 Chrome / Edge，并在 HTTPS 下访问。</div>
          </div>
        </div>

        <div class="form-section">
          <div class="form-group">
            <label>WebSocket 网关地址（中转服务）</label>
            <input id="wsUrlInput" type="text" placeholder="">
          </div>

          <div class="form-group">
            <label>文本输入（可选）</label>
            <textarea id="textInput" placeholder="在这里输入文字消息，也会通过同一个通道发送给模型。"></textarea>
            <div class="btn-row" style="margin-top:6px;">
              <button type="button" class="secondary-btn" id="sendTextBtn">发送文本</button>
              <button type="button" class="secondary-btn" id="clearLogBtn">清空记录</button>
            </div>
          </div>

          <div class="form-group">
            <label>实时语音控制</label>
            <div class="btn-row">
              <button type="button" class="primary-btn" id="startBtn">连接 + 开始语音</button>
              <button type="button" class="secondary-btn" id="stopBtn">停止对话</button>
            </div>
            <div class="small-hint">对话开始后，浏览器会持续推送本地麦克风音频到服务器，服务器调用云端模型并返回语音结果。</div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer class="footer">© 2025 DATA HAMMER LAB · Realtime Talking · All Rights Reserved</footer>
  
<script>
    const $ = (id) => document.getElementById(id);
  
    const wsUrlInput = $("wsUrlInput");
    const sendTextBtn = $("sendTextBtn");
    const clearLogBtn = $("clearLogBtn");
    const startBtn = $("startBtn");
    const stopBtn = $("stopBtn");
    const textInput = $("textInput");
    const chatLog = $("chatLog");
  
    const statusDot = $("statusDot");
    const statusText = $("statusText");
    const latencyLabel = $("latencyLabel");
  
    let ws = null;
    let wsReadyPromise = null;
  
    let audioCtx = null;
    let micStream = null;
    let sourceNode = null;
    let processor = null;
    let muteGain = null;
    let running = false;
  
    const ttsQueue = [];
    let ttsPlaying = false;
  
    function setStatus(online, text) {
      statusDot.classList.toggle("online", !!online);
      statusText.textContent = text;
    }
  
    function appendMsg(role, content) {
      const div = document.createElement("div");
      div.className = `chat-msg ${role}`;
      div.innerHTML = `<span class="role">${role === "user" ? "用户" : role === "assistant" ? "助手" : "系统"}</span>
                       <span class="content"></span>`;
      div.querySelector(".content").textContent = content;
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
  
    function getWsUrl() {
      const manual = (wsUrlInput.value || "").trim();
      if (manual) return manual;

  // 强制本机
      return `ws://127.0.0.1:8765`;
    }
  
    function waitWsOpen() {
      if (!ws) return Promise.reject(new Error("ws not created"));
      if (ws.readyState === WebSocket.OPEN) return Promise.resolve();
      if (wsReadyPromise) return wsReadyPromise;
  
      wsReadyPromise = new Promise((resolve, reject) => {
        const onOpen = () => { cleanup(); resolve(); };
        const onErr = (e) => { cleanup(); reject(e); };
        const onClose = () => { cleanup(); reject(new Error("ws closed")); };
  
        const cleanup = () => {
          ws.removeEventListener("open", onOpen);
          ws.removeEventListener("error", onErr);
          ws.removeEventListener("close", onClose);
          wsReadyPromise = null;
        };
  
        ws.addEventListener("open", onOpen);
        ws.addEventListener("error", onErr);
        ws.addEventListener("close", onClose);
      });
  
      return wsReadyPromise;
    }
  
    function connectWS() {
      const url = getWsUrl();
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        appendMsg("system", "WS 已连接/连接中");
        return;
      }
  
      ws = new WebSocket(url);
      ws.binaryType = "arraybuffer";
      wsReadyPromise = null;
  
      setStatus(false, "连接中…");
      latencyLabel.textContent = "连接中…";
  
      ws.onopen = () => {
        setStatus(true, "已连接");
        latencyLabel.textContent = "已连接";
        appendMsg("system", "WS open: " + url);
      };
  
      ws.onclose = () => {
        setStatus(false, "未连接");
        latencyLabel.textContent = "连接关闭";
        appendMsg("system", "WS closed.");
      };
  
      ws.onerror = () => {
        setStatus(false, "连接错误");
        latencyLabel.textContent = "连接错误";
        appendMsg("system", "WS error.");
      };
  
      ws.onmessage = (evt) => {
        if (typeof evt.data === "string") {
          let msg;
          try { msg = JSON.parse(evt.data); } catch { appendMsg("system", "JSON parse error"); return; }
  
          if (msg.type === "asr") appendMsg("assistant", "ASR: " + msg.text);
          else if (msg.type === "partial") latencyLabel.textContent = "识别中… " + (msg.text || "");
          else if (msg.type === "log") appendMsg("system", msg.message || "");
          else if (msg.type === "error") appendMsg("system", "ERROR: " + (msg.message || ""));
          else if (msg.type === "upstream") {
            // 你后端目前是透传 parse_response：先显示摘要，方便你对齐字段
            const s = JSON.stringify(msg.data);
            appendMsg("system", "UPSTREAM: " + s.slice(0, 400));
          } else {
            appendMsg("system", "JSON: " + JSON.stringify(msg));
          }
          return;
        }
  
        // 二进制：TTS PCM 16k s16le mono（如果后端推了）
        enqueueTtsPcm(evt.data);
      };
    }
  
    // ===== 音频：重采样 + PCM16 =====
    function floatTo16BitPCM(float32Array) {
      const buf = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buf);
      for (let i = 0; i < float32Array.length; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
      return buf;
    }
  
    function resampleTo16k(float32Array, inRate) {
      const outRate = 16000;
      if (inRate === outRate) return float32Array;
      const ratio = inRate / outRate;
      const outLen = Math.round(float32Array.length / ratio);
      const out = new Float32Array(outLen);
      for (let i = 0; i < outLen; i++) {
        const idx = i * ratio;
        const i0 = Math.floor(idx);
        const i1 = Math.min(i0 + 1, float32Array.length - 1);
        const frac = idx - i0;
        out[i] = float32Array[i0] * (1 - frac) + float32Array[i1] * frac;
      }
      return out;
    }
  
    // ===== TTS 播放队列 =====
    function enqueueTtsPcm(arrayBuffer) {
      ttsQueue.push(arrayBuffer);
      if (!ttsPlaying) playNextTts();
    }
  
    async function playNextTts() {
      if (ttsQueue.length === 0) { ttsPlaying = false; return; }
      ttsPlaying = true;
      const buf = ttsQueue.shift();
      await playPcm16kS16LE(buf);
      playNextTts();
    }
  
    async function playPcm16kS16LE(arrayBuffer) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();
  
      const int16 = new Int16Array(arrayBuffer);
      const float32 = new Float32Array(int16.length);
      for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;
  
      const audioBuffer = audioCtx.createBuffer(1, float32.length, 16000);
      audioBuffer.copyToChannel(float32, 0);
  
      return new Promise((resolve) => {
        const node = audioCtx.createBufferSource();
        node.buffer = audioBuffer;
        node.connect(audioCtx.destination);
        node.onended = resolve;
        node.start();
      });
    }
  
    // ===== MIC streaming =====
    async function startMic() {
      connectWS();
      await waitWsOpen();
  
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();
  
      micStream = await navigator.mediaDevices.getUserMedia({
        audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true, autoGainControl: true }
      });
  
      sourceNode = audioCtx.createMediaStreamSource(micStream);
      processor = audioCtx.createScriptProcessor(4096, 1, 1);
  
      muteGain = audioCtx.createGain();
      muteGain.gain.value = 0;
  
      const inRate = audioCtx.sampleRate;
      latencyLabel.textContent = `Mic OK · ${inRate} Hz`;
  
      processor.onaudioprocess = (e) => {
        if (!running) return;
        const input = e.inputBuffer.getChannelData(0);
        const resampled = resampleTo16k(input, inRate);
        const pcmBuf = floatTo16BitPCM(resampled);
        if (ws && ws.readyState === WebSocket.OPEN) ws.send(pcmBuf);
      };
  
      sourceNode.connect(processor);
      processor.connect(muteGain);
      muteGain.connect(audioCtx.destination);
  
      ws.send(JSON.stringify({ type: "start", format: "pcm_s16le", sample_rate: 16000, channels: 1 }));
      running = true;
      appendMsg("system", "语音已开始（持续推送麦克风）");
    }
  
    function stopMic() {
      running = false;
      if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: "stop" }));
  
      if (processor) processor.disconnect();
      if (sourceNode) sourceNode.disconnect();
      if (muteGain) muteGain.disconnect();
      if (micStream) micStream.getTracks().forEach(t => t.stop());
  
      processor = null;
      sourceNode = null;
      muteGain = null;
      micStream = null;
  
      latencyLabel.textContent = "已停止";
      appendMsg("system", "语音已停止");
    }
  
    // ===== UI =====
    startBtn.onclick = async () => {
      try { await startMic(); }
      catch (e) { appendMsg("system", "启动失败: " + e); }
    };
  
    stopBtn.onclick = () => stopMic();
  
    sendTextBtn.onclick = async () => {
      const text = (textInput.value || "").trim();
      if (!text) return;
  
      connectWS();
      try { await waitWsOpen(); } catch { appendMsg("system", "WS 未连接"); return; }
  
      ws.send(JSON.stringify({ type: "text", text }));
      appendMsg("user", text);
      textInput.value = "";
    };
  
    clearLogBtn.onclick = () => {
      chatLog.innerHTML = "";
      appendMsg("system", "已清空记录");
    };
  
    // 默认填一个合理值（可改）
    if (!wsUrlInput.value) wsUrlInput.value = "";
  
    setStatus(false, "未连接");
</script>
  