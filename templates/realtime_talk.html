<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>å®æ—¶å¯¹è¯ç•Œé¢ - DATA HAMMER GROUP</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/app.css') }}">
</head>

<body class="main-bg realtime-page">
  <header class="nav">
    <div class="nav-logo">
      <div class="nav-logo-mark"></div>
      <div>
        <div class="nav-logo-text-main">DATA HAMMER GROUP</div>
        <div class="nav-logo-text-sub">Intelligent Talking System</div>
      </div>
    </div>
    <nav class="nav-links">
      <a href="/">é¦–é¡µ</a>
      <a href="/chat_system">äººæœºå¯¹è¯</a>
      <a href="/model_training">æ¨¡å‹è®­ç»ƒ</a>
      <a href="/video_generation">è§†é¢‘ç”Ÿæˆ</a>
      <a href="/realtime_talk.html">å®æ—¶å¯¹è¯</a>
      <a href="/about">å…³äºæˆ‘ä»¬</a>
    </nav>
    <button class="nav-cta" onclick="window.location.href='/'">è¿”å›é¦–é¡µ</button>
  </header>

  <main class="page-wrapper">
    <div class="page-inner">
      <div class="hero-card">
        <div class="badge"><div class="badge-dot"></div><span>REALTIME Â· DATA HAMMER TALKING SYSTEM</span></div>
        <h1 class="headline">å®æ—¶å¯¹è¯ç•Œé¢ Â· <span>LIVE</span></h1>
        <p class="subline">ä½¿ç”¨æœ¬åœ°éº¦å…‹é£ä¸äº‘ç«¯å¯¹è¯æ¨¡å‹å®æ—¶äº¤æµ Â· è¯­éŸ³è¾“å…¥ Â· è¯­éŸ³è¾“å‡º Â· ä½å»¶è¿Ÿ</p>
        <div class="status-pill">
          <div id="statusDot" class="status-dot"></div>
          <span id="statusText">æœªè¿æ¥</span>
        </div>
      </div>

      <div class="video-page-container">
        <div class="dialog-display">
          <div class="dialog-card">
            <div class="dialog-card-header">
              <div class="tab-menu">
                <button class="tab-button active" data-tab-target="guidePane">ä½¿ç”¨æŒ‡å—</button>
                <button class="tab-button" data-tab-target="logPane">è¯¦ç»†è®°å½•</button>
              </div>
              <span class="inline-text" id="latencyLabel">ç­‰å¾…è¿æ¥...</span>
            </div>
            <div class="tab-pane guide-pane active" data-tab-pane id="guidePane">
              <h4>å¦‚ä½•å¼€å§‹å®æ—¶å¯¹è¯</h4>
              <p>æœ¬ç³»ç»Ÿéœ€è¦ä½¿ç”¨ WebSocket ä¸­è½¬æœåŠ¡äº¤äº’ã€‚<span class="guide-highlight">æ¨èç½‘å…³ï¼šws://127.0.0.1:8765</span> ç›´æ¥å¡«å†™åœ¨å³ä¾§çš„è¾“å…¥æ¡†ä¸­ï¼Œå¯è·å¾—æœ€ä½å»¶è¿Ÿã€‚</p>
              <ul class="guide-steps">
                <li class="guide-step"><strong>1. æ£€æŸ¥æµè§ˆå™¨</strong> ï¼šä½¿ç”¨ä¸ä½äº Chrome/Edge 118 çš„ç‰ˆæœ¬ï¼Œå¹¶åœ¨ HTTPS æˆ– localhost ä¸‹è¿è¡Œã€‚</li>
                <li class="guide-step"><strong>2. ç»™äºˆéº¦å…‹é£æƒé™</strong> ï¼šé¦–æ¬¡ç‚¹å‡»ã€Œè¿æ¥ + å¼€å§‹è¯­éŸ³ã€æ—¶ï¼Œç³»ç»Ÿä¼šå¼¹å‡ºæƒé™æç¤ºï¼Œè¯·é€‰æ‹©å…è®¸ã€‚</li>
                <li class="guide-step"><strong>3. è¾“å…¥ä¸­è½¬æœåŠ¡åœ°å€</strong> ï¼šå¦‚æœä½¿ç”¨æœ¬åœ°ä¸­è½¬ï¼Œç›´æ¥ä¿ç•™æ¨èå€¼ ws://127.0.0.1:8765ï¼›è‹¥éœ€è¿æ¥è¿œç¨‹ï¼Œè¯·æŒ‰éœ€å¡«å†™ã€‚</li>
                <li class="guide-step"><strong>4. å¼€å§‹å¯¹è¯</strong> ï¼šç‚¹å‡»å³ä¾§æŒ‰é’®åï¼Œæç¤º"å·²è¿æ¥"å³å¯è¯´è¯ï¼Œä¹Ÿå¯ä»¥åœ¨æ–‡æœ¬æ¡†è¾“å…¥æ–‡å­—æ¶ˆæ¯ã€‚</li>
              </ul>
            </div>
            <div class="tab-pane" data-tab-pane id="logPane">
              <div id="chatLog" class="chat-log">
                <div class="chat-msg system">
                  <span class="role">ç³»ç»Ÿ</span>
                  <span class="content">æ¬¢è¿ä½¿ç”¨å®æ—¶å¯¹è¯ï¼Œç‚¹å‡»å³ä¾§ã€Œè¿æ¥ + å¼€å§‹è¯­éŸ³ã€ï¼Œå¹¶ç¡®è®¤æµè§ˆå™¨éº¦å…‹é£æƒé™å·²å¼€å¯ã€‚</span>
                </div>
              </div>
              <div class="small-hint">æç¤ºï¼šä¸ºäº†æ›´å¥½çš„éº¦å…‹é£æƒé™ä½“éªŒï¼Œå»ºè®®ä½¿ç”¨ Chrome / Edgeï¼Œå¹¶åœ¨ HTTPS ä¸‹è®¿é—®ã€‚</div>
            </div>
          </div>
        </div>

        <div class="form-section">
          <div class="form-group">
            <label>WebSocket ç½‘å…³åœ°å€ï¼ˆä¸­è½¬æœåŠ¡ï¼‰</label>
            <input id="wsUrlInput" type="text" placeholder="">
          </div>

          <div class="form-group">
            <label>æ–‡æœ¬è¾“å…¥ï¼ˆå¯é€‰ï¼‰</label>
            <textarea id="textInput" placeholder="åœ¨è¿™é‡Œè¾“å…¥æ–‡å­—æ¶ˆæ¯ï¼Œä¹Ÿä¼šé€šè¿‡åŒä¸€ä¸ªé€šé“å‘é€ç»™æ¨¡å‹ã€‚"></textarea>
            <div class="btn-row" style="margin-top:6px;">
              <button type="button" class="secondary-btn" id="sendTextBtn">å‘é€æ–‡æœ¬</button>
              <button type="button" class="secondary-btn" id="clearLogBtn">æ¸…ç©ºè®°å½•</button>
            </div>
          </div>

          <div class="form-group">
            <label>å®æ—¶è¯­éŸ³æ§åˆ¶</label>
            <!-- æ–°å¢ï¼šéŸ³é‡æ§åˆ¶åŒºåŸŸï¼ˆå¤ç”¨å…±ç”¨CSSï¼‰ -->
            <div class="volume-control" style="margin-bottom: 12px;">
              <label for="volumeSlider">è¯­éŸ³è¾“å‡ºéŸ³é‡</label>
              <div class="volume-slider-wrapper">
                <span class="volume-icon">ğŸ”Š</span>
                <input type="range" id="volumeSlider" min="0" max="1" step="0.05" value="1">
                <span class="volume-value" id="volumeValue">100%</span>
              </div>
            </div>
            <!-- åŸæœ‰æŒ‰é’®åŒºåŸŸ -->
            <div class="btn-row">
              <button type="button" class="primary-btn" id="startBtn">è¿æ¥ + å¼€å§‹è¯­éŸ³</button>
              <button type="button" class="secondary-btn" id="stopBtn">åœæ­¢å¯¹è¯</button>
            </div>
            <div class="small-hint">å¯¹è¯å¼€å§‹åï¼Œæµè§ˆå™¨ä¼šæŒç»­æ¨é€æœ¬åœ°éº¦å…‹é£éŸ³é¢‘åˆ°æœåŠ¡å™¨ï¼ŒæœåŠ¡å™¨è°ƒç”¨äº‘ç«¯æ¨¡å‹å¹¶è¿”å›è¯­éŸ³ç»“æœã€‚</div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer class="footer">Â© 2025 DATA HAMMER LAB Â· Realtime Talking Â· All Rights Reserved</footer>
  
<script>
    const $ = (id) => document.getElementById(id);
  
    const wsUrlInput = $("wsUrlInput");
    const sendTextBtn = $("sendTextBtn");
    const clearLogBtn = $("clearLogBtn");
    const startBtn = $("startBtn");
    const stopBtn = $("stopBtn");
    const textInput = $("textInput");
    const chatLog = $("chatLog");
    const tabButtons = document.querySelectorAll(".tab-button");
    const tabPanes = document.querySelectorAll("[data-tab-pane]");
  
    const statusDot = $("statusDot");
    const statusText = $("statusText");
    const latencyLabel = $("latencyLabel");

    // æ–°å¢ï¼šéŸ³é‡æ§åˆ¶ç›¸å…³å…ƒç´ 
    const volumeSlider = $("volumeSlider");
    const volumeValue = $("volumeValue");
    let volumeGainNode = null; // éŸ³é‡æ§åˆ¶èŠ‚ç‚¹
  
    let ws = null;
    let wsReadyPromise = null;
  
    let audioCtx = null;
    let micStream = null;
    let sourceNode = null;
    let processor = null;
    let muteGain = null;
    let running = false;
  
    const ttsQueue = [];
    let ttsPlaying = false;
  
    function setStatus(online, text) {
      statusDot.classList.toggle("online", !!online);
      statusText.textContent = text;
    }
  
    function appendMsg(role, content) {
      const roleMap = { user: "ç”¨æˆ·", assistant: "åŠ©æ‰‹", system: "ç³»ç»Ÿ" };
      const div = document.createElement("div");
      div.className = `chat-msg ${role}`;
      div.innerHTML = `<span class="role">${roleMap[role] || roleMap.system}</span>
                       <span class="content"></span>`;
      div.querySelector(".content").textContent = content;
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function activateTab(targetId) {
      tabButtons.forEach(btn => btn.classList.toggle("active", btn.dataset.tabTarget === targetId));
      tabPanes.forEach(pane => pane.classList.toggle("active", pane.id === targetId));
    }
  
    function getWsUrl() {
      const manual = (wsUrlInput.value || "").trim();
      if (manual) return manual;
    
      // å¼ºåˆ¶æœ¬æœº
      return `ws://127.0.0.1:8765`;
    }
  
    function waitWsOpen() {
      if (!ws) return Promise.reject(new Error("å°šæœªåˆ›å»ºè¿æ¥"));
      if (ws.readyState === WebSocket.OPEN) return Promise.resolve();
      if (wsReadyPromise) return wsReadyPromise;
  
      wsReadyPromise = new Promise((resolve, reject) => {
        const onOpen = () => { cleanup(); resolve(); };
        const onErr = (e) => { cleanup(); reject(e); };
        const onClose = () => { cleanup(); reject(new Error("è¿æ¥å·²å…³é—­")); };
  
        const cleanup = () => {
          ws.removeEventListener("open", onOpen);
          ws.removeEventListener("error", onErr);
          ws.removeEventListener("close", onClose);
          wsReadyPromise = null;
        };
  
        ws.addEventListener("open", onOpen);
        ws.addEventListener("error", onErr);
        ws.addEventListener("close", onClose);
      });
  
      return wsReadyPromise;
    }
  
    function connectWS() {
      const url = getWsUrl();
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        appendMsg("system", "å·²ç»è¿æ¥åˆ°å®æ—¶ç½‘å…³ï¼Œæ— éœ€é‡å¤æ“ä½œã€‚");
        return;
      }
  
      ws = new WebSocket(url);
      ws.binaryType = "arraybuffer";
      wsReadyPromise = null;
  
      setStatus(false, "è¿æ¥ä¸­â€¦");
      latencyLabel.textContent = "è¿æ¥ä¸­â€¦";
  
      ws.onopen = () => {
        setStatus(true, "å·²è¿æ¥");
        latencyLabel.textContent = "å·²è¿æ¥";
        appendMsg("system", "å·²è¿æ¥åˆ°å®æ—¶ç½‘å…³ï¼š" + url);
      };
  
      ws.onclose = () => {
        setStatus(false, "æœªè¿æ¥");
        latencyLabel.textContent = "è¿æ¥å…³é—­";
        appendMsg("system", "å®æ—¶å¯¹è¯å·²æ–­å¼€ï¼Œå¯ç¨åé‡æ–°è¿æ¥ã€‚");
      };
  
      ws.onerror = () => {
        setStatus(false, "è¿æ¥é”™è¯¯");
        latencyLabel.textContent = "è¿æ¥é”™è¯¯";
        appendMsg("system", "è¿æ¥é‡åˆ°é—®é¢˜ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–ç½‘å…³åœ°å€ã€‚");
      };
  
      ws.onmessage = (evt) => {
        if (typeof evt.data === "string") {
          let msg;
          try { msg = JSON.parse(evt.data); } catch { appendMsg("system", "æ”¶åˆ°çš„æœåŠ¡æ¶ˆæ¯æš‚æ—¶æ— æ³•è¯†åˆ«ã€‚"); return; }

          if (msg.type === "asr") appendMsg("assistant", "è¯†åˆ«ç»“æœï¼š" + msg.text);
          else if (msg.type === "partial") latencyLabel.textContent = "è¯†åˆ«ä¸­â€¦ " + (msg.text || "");
          else if (msg.type === "log") appendMsg("system", msg.message || "");
          else if (msg.type === "error") appendMsg("system", "æœåŠ¡æç¤ºï¼š" + (msg.message || "å‡ºç°æœªçŸ¥é”™è¯¯"));
          else if (msg.type === "upstream") {
            appendMsg("system", "æœåŠ¡æ­£åœ¨å‡†å¤‡æ›´å®Œæ•´çš„å›ç­”ï¼Œè¯·ç¨å€™â€¦");
          } else {
            appendMsg("system", "æ”¶åˆ°æ–°çš„æœåŠ¡æ¶ˆæ¯ã€‚");
          }
          return;
        }
  
        // äºŒè¿›åˆ¶ï¼šTTS PCM 16k s16le monoï¼ˆå¦‚æœåç«¯æ¨äº†ï¼‰
        enqueueTtsPcm(evt.data);
      };
    }
  
    // ===== éŸ³é¢‘ï¼šé‡é‡‡æ · + PCM16 =====
    function floatTo16BitPCM(float32Array) {
      const buf = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buf);
      for (let i = 0; i < float32Array.length; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
      return buf;
    }
  
    function resampleTo16k(float32Array, inRate) {
      const outRate = 16000;
      if (inRate === outRate) return float32Array;
      const ratio = inRate / outRate;
      const outLen = Math.round(float32Array.length / ratio);
      const out = new Float32Array(outLen);
      for (let i = 0; i < outLen; i++) {
        const idx = i * ratio;
        const i0 = Math.floor(idx);
        const i1 = Math.min(i0 + 1, float32Array.length - 1);
        const frac = idx - i0;
        out[i] = float32Array[i0] * (1 - frac) + float32Array[i1] * frac;
      }
      return out;
    }
  
    // ===== TTS æ’­æ”¾é˜Ÿåˆ— =====
    function enqueueTtsPcm(arrayBuffer) {
      ttsQueue.push(arrayBuffer);
      if (!ttsPlaying) playNextTts();
    }
  
    async function playNextTts() {
      if (ttsQueue.length === 0) { ttsPlaying = false; return; }
      ttsPlaying = true;
      const buf = ttsQueue.shift();
      await playPcm16kS16LE(buf);
      playNextTts();
    }
  
    async function playPcm16kS16LE(arrayBuffer) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();
      
      // æ–°å¢ï¼šåˆå§‹åŒ–éŸ³é‡æ§åˆ¶èŠ‚ç‚¹
      if (!volumeGainNode) {
        volumeGainNode = audioCtx.createGain();
        volumeGainNode.gain.value = volumeSlider.value;
        volumeGainNode.connect(audioCtx.destination);
      }
  
      const int16 = new Int16Array(arrayBuffer);
      const float32 = new Float32Array(int16.length);
      for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;
  
      const audioBuffer = audioCtx.createBuffer(1, float32.length, 16000);
      audioBuffer.copyToChannel(float32, 0);
  
      return new Promise((resolve) => {
        const node = audioCtx.createBufferSource();
        node.buffer = audioBuffer;
        // æ–°å¢ï¼šé€šè¿‡éŸ³é‡èŠ‚ç‚¹è¿æ¥åˆ°è¾“å‡ºï¼Œè€Œéç›´æ¥è¿destination
        node.connect(volumeGainNode);
        node.onended = resolve;
        node.start();
      });
    }
  
    // ===== MIC streaming =====
    async function startMic() {
      connectWS();
      await waitWsOpen();
  
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();
  
      micStream = await navigator.mediaDevices.getUserMedia({
        audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true, autoGainControl: true }
      });
  
      sourceNode = audioCtx.createMediaStreamSource(micStream);
      processor = audioCtx.createScriptProcessor(4096, 1, 1);
  
      muteGain = audioCtx.createGain();
      muteGain.gain.value = 0;
  
      const inRate = audioCtx.sampleRate;
      latencyLabel.textContent = `éº¦å…‹é£å°±ç»ª Â· ${inRate} Hz`;
  
      processor.onaudioprocess = (e) => {
        if (!running) return;
        const input = e.inputBuffer.getChannelData(0);
        const resampled = resampleTo16k(input, inRate);
        const pcmBuf = floatTo16BitPCM(resampled);
        if (ws && ws.readyState === WebSocket.OPEN) ws.send(pcmBuf);
      };
  
      sourceNode.connect(processor);
      processor.connect(muteGain);
      muteGain.connect(audioCtx.destination);
  
      ws.send(JSON.stringify({ type: "start", format: "pcm_s16le", sample_rate: 16000, channels: 1 }));
      running = true;
      appendMsg("system", "å®æ—¶è¯­éŸ³å·²å¼€å§‹ï¼Œæ­£åœ¨ä¼ è¾“éº¦å…‹é£å£°éŸ³ã€‚");
    }
  
    function stopMic() {
      running = false;
      if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: "stop" }));
  
      if (processor) processor.disconnect();
      if (sourceNode) sourceNode.disconnect();
      if (muteGain) muteGain.disconnect();
      if (micStream) micStream.getTracks().forEach(t => t.stop());
  
      processor = null;
      sourceNode = null;
      muteGain = null;
      micStream = null;
  
      latencyLabel.textContent = "å·²åœæ­¢";
      appendMsg("system", "å®æ—¶è¯­éŸ³å·²åœæ­¢ï¼Œéº¦å…‹é£å·²å…³é—­ã€‚");
    }
  
    // ===== æ–°å¢ï¼šéŸ³é‡æ§åˆ¶é€»è¾‘ =====
    function initVolumeControl() {
      // åˆå§‹åŒ–éŸ³é‡æ˜¾ç¤º
      volumeValue.textContent = `${Math.round(volumeSlider.value * 100)}%`;
      
      // æ»‘å—æ”¹å˜æ—¶æ›´æ–°éŸ³é‡
      volumeSlider.addEventListener('input', function() {
        const volume = parseFloat(this.value);
        // æ›´æ–°éŸ³é‡èŠ‚ç‚¹
        if (volumeGainNode) {
          volumeGainNode.gain.value = volume;
        }
        // æ›´æ–°æ˜¾ç¤º
        volumeValue.textContent = `${Math.round(volume * 100)}%`;
        // åˆ‡æ¢éŸ³é‡å›¾æ ‡
        const volumeIcon = document.querySelector('.volume-icon');
        if (volume === 0) {
          volumeIcon.textContent = 'ğŸ”‡';
        } else if (volume < 0.5) {
          volumeIcon.textContent = 'ğŸ”ˆ';
        } else {
          volumeIcon.textContent = 'ğŸ”Š';
        }
      });
    }
  
    // ===== UI =====
    startBtn.onclick = async () => {
      try { await startMic(); }
      catch (e) { appendMsg("system", "æ— æ³•å¯åŠ¨å®æ—¶è¯­éŸ³ï¼š" + (e && e.message ? e.message : e)); }
    };
  
    stopBtn.onclick = () => stopMic();
  
    sendTextBtn.onclick = async () => {
      const text = (textInput.value || "").trim();
      if (!text) return;
  
      connectWS();
      try { await waitWsOpen(); } catch { appendMsg("system", "å°šæœªè¿æ¥åˆ°å®æ—¶ç½‘å…³ï¼Œè¯·å…ˆç‚¹å‡»\"è¿æ¥ + å¼€å§‹è¯­éŸ³\"ã€‚"); return; }
  
      ws.send(JSON.stringify({ type: "text", text }));
      appendMsg("user", text);
      textInput.value = "";
    };
  
    clearLogBtn.onclick = () => {
      chatLog.innerHTML = "";
      appendMsg("system", "å·²æ¸…ç©ºè®°å½•");
    };
  
    // é»˜è®¤å¡«ä¸€ä¸ªåˆç†å€¼ï¼ˆå¯æ”¹ï¼‰
    if (!wsUrlInput.value) wsUrlInput.value = "";

    // æµè§ˆå™¨èƒ½åŠ›æ£€æµ‹ï¼šæé†’å¹¶ç¦ç”¨å¼€å§‹æŒ‰é’®ï¼ˆå¦‚æœä¸æ”¯æŒ getUserMediaï¼‰
    if (!navigator.mediaDevices || typeof navigator.mediaDevices.getUserMedia !== 'function') {
      appendMsg("system", "å½“å‰æµè§ˆå™¨æ— æ³•æ‰“å¼€éº¦å…‹é£ï¼Œè¯·ä½¿ç”¨æœ€æ–°ç‰ˆ Chrome/Edgeï¼Œå¹¶é€šè¿‡ HTTPS æˆ– localhost è®¿é—®ã€‚");
      try { startBtn.disabled = true; } catch (e) {}
    }

    // åˆå§‹åŒ–æ ‡ç­¾åˆ‡æ¢å’ŒéŸ³é‡æ§åˆ¶
    tabButtons.forEach(btn => btn.addEventListener("click", () => activateTab(btn.dataset.tabTarget)));
    setStatus(false, "æœªè¿æ¥");
    initVolumeControl(); // åˆå§‹åŒ–éŸ³é‡æ§åˆ¶
</script>
</body>
</html>